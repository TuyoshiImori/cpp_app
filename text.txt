This is one way to solve it.

Step 1: Binarisation
import os
import cv2
import numpy as np
import pandas as pd

### reading input image
image_path='test_sample.jpg'
image=cv2.imread(image_path)

### converting BGR to Grayscale
gray_scale=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)

### Binarising image
th1,img_bin = cv2.threshold(gray_scale,180,225,cv2.THRESH_OTSU)

Binary image:

binary image

Step 2: Finding horizontal and vertical lines
### defining kernels

lWidth = 2
lineMinWidth = 15

kernal1 = np.ones((lWidth,lWidth), np.uint8)
kernal1h = np.ones((1,lWidth), np.uint8)
kernal1v = np.ones((lWidth,1), np.uint8)

kernal6 = np.ones((lineMinWidth,lineMinWidth), np.uint8)
kernal6h = np.ones((1,lineMinWidth), np.uint8)
kernal6v = np.ones((lineMinWidth,1), np.uint8)

### finding horizontal lines
img_bin_h = cv2.morphologyEx(~img_bin, cv2.MORPH_CLOSE, kernal1h) # bridge small gap in horizonntal lines
img_bin_h = cv2.morphologyEx(img_bin_h, cv2.MORPH_OPEN, kernal6h) # kep ony horiz lines by eroding everything else in hor direction
Horizontal Lines:

horizontal lines

## detect vert lines
img_bin_v = cv2.morphologyEx(~img_bin, cv2.MORPH_CLOSE, kernal1v)  # bridge small gap in vert lines
img_bin_v = cv2.morphologyEx(img_bin_v, cv2.MORPH_OPEN, kernal6v)# kep ony vert lines by eroding everything else in vert direction
Vertical Lines:

vertical lines

Step 3: combining horizontal and vertical lines
def fix(img):
    img[img>127]=255
    img[img<127]=0
    return img
img_bin_final = fix(fix(img_bin_h)|fix(img_bin_v))

Combined binary output:

binary final

Step 4: Find rectangles using Connected Components
### getting labels
ret, labels, stats,centroids = cv2.connectedComponentsWithStats(~img_bin_final, connectivity=8, ltype=cv2.CV_32S)

### drawing recangles for visualisation
for x,y,w,h,area in stats[2:]:
    cv2.rectangle(image,(x,y),(x+w,y+h),(0,0,255),2)
Final output: